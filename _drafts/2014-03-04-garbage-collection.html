---
layout: post
title: Garbage Collection
date: 2014-03-04 23:48:18.000000000 -08:00
categories: []
tags: []
status: draft
type: post
published: false
meta:
  blogger_blog: www.hakimhanif.com
  blogger_author: Hakim Hanif
  blogger_internal: "/feeds/2751951855380724535/posts/default/4001638715546988800"
author:
  login: hakimhanif
  email: hakim.hanif@gmail.com
  display_name: hakimhanif
  first_name: ''
  last_name: ''
---
<p><span style="font-family: 'Times New Roman'; font-size: medium; ">
<div style="background-image: initial; background-attachment: initial; background-origin: initial; background-clip: initial; background-color: rgb(255, 255, 255); font: normal normal normal 13px/19px Georgia, 'Times New Roman', 'Bitstream Charter', Times, serif; padding-top: 0.6em; padding-right: 0.6em; padding-bottom: 0.6em; padding-left: 0.6em; margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; background-position: initial initial; background-repeat: initial initial; ">
<p style="text-align: justify;">Now, if you are familiar with Java, then for sure you know what I am going to talk about. But if you are from the C/C++ world, then let me give me brief overview of what type of garbage we are talking about.</p>
<p style="text-align: justify;">Basically, this garbage is nothing but the memory which is being allocated but is no longer used. Yeah, I know - you did new or malloc() 2000 times but come on who cares to do delete or free(). But by not freeing the memory, you are wasting lots and lots of memory which could be used by other processes.</p>
<p style="text-align: justify;">This is where garbage collection comes to rescue. You can allocate the memory but the deallocation (or free) of the memory is done for you. So  is this service free of cost? Hmm.. not exactly. It has some overheads but then its always better than not deallocating the memory at all.</p>
<p style="text-align: justify;">Ok. Now, how you implement so called garbage collection?</p>
<p style="text-align: justify;">Well, there are lots and lots of methods being tried out to make it as efficient as possible. Lets look at some of them::</p>
<p><span mce_name="strong" mce_style="font-weight: bold;" style="font-weight: bold; "></span></p>
<p><span mce_name="strong" mce_style="font-weight: bold;" style="font-weight: bold; "></span></p>
<p><span mce_name="strong" mce_style="font-weight: bold;" style="font-weight: bold; "></span></p>
<p><span mce_name="strong" mce_style="font-weight: bold;" style="font-weight: bold; "></span></p>
<div style="text-align: justify;"><b>Reference counting:</b></div>
<div style="text-align: justify;"><span mce_style="font-weight: normal;" style="font-weight: normal; "><br /></span></div>
<div style="text-align: justify;"><span mce_style="font-weight: normal;" style="font-weight: normal; ">Reference counting was an early garbage collection strategy; here a reference count is maintained for each object. When an object is first created its reference count is set to one. When any other object or root is assigned a reference to that object, the object's count is incremented. When a reference to an object goes out of scope or is assigned a new value, the object's count is decremented. Any object with a reference count of zero can be garbage collected. When an object is garbage collected, any objects that it refers to has their reference counts decremented. In this way the garbage collection of one object may lead to the subsequent garbage collection of other objects.</span></div>
<div style="text-align: justify;"><span mce_style="font-weight: normal;" style="font-weight: normal; "><br /></span></div>
<div style="text-align: justify;"><span mce_style="font-weight: normal;" style="font-weight: normal; ">An </span><b>advantage</b><span mce_style="font-weight: normal;" style="font-weight: normal; "> of this scheme is that it can run in small chunks of time closely interwoven with the execution of the program. This characteristic makes it particularly suitable for real-time environments where the program can't be interrupted for very long.</span></div>
<div style="text-align: justify;"><span mce_style="font-weight: normal;" style="font-weight: normal; ">A </span><b>disadvantage</b><span mce_style="font-weight: normal;" style="font-weight: normal; "> of reference counting is that it does not detect cycles. A cycle is two or more objects that refer to one another, for example, a parent object that has a reference to its child object, which has a reference back to its parent. These objects will never have a reference count of zero even though they may be unreachable by the roots of the executing program. Another disadvantage is the overhead of incrementing and decrementing the reference count each time. Because of these disadvantages, reference counting currently is out of favor. It is more likely that the JVMs you encounter in the real world will use a tracing algorithm in their garbage-collected heaps.</span></div>
<div></div>
<div style="text-align: justify;"></div>
<div style="text-align: justify;"><b>Tracing collectors</b></div>
<div style="text-align: justify;"><span mce_style="font-weight: normal;" style="font-weight: normal; ">Tracing garbage collectors trace out the graph of object references starting with the root nodes. Objects that are encountered during the trace are marked in some way. Marking is generally done by either setting flags in the objects themselves or by setting flags in a separate bitmap. After the trace is complete, unmarked objects are known to be unreachable and can be garbage collected.</span></div>
<div style="text-align: justify;"><span mce_style="font-weight: normal;" style="font-weight: normal; ">The basic tracing algorithm is called </span>mark and sweep<span mce_style="font-weight: normal;" style="font-weight: normal; ">. This name refers to the two phases of the garbage collection process. In the mark phase, the garbage collector traverses the tree of references and marks each object it encounters. In the sweep phase unmarked objects are freed, and the resulting memory is made available to the executing program. In the JVM the sweep phase must include finalization of objects.</span></div>
<div style="text-align: justify;"><span mce_style="font-weight: normal;" style="font-weight: normal; ">Some Java objects have finalizers, others do not. Objects with finalizers that are left unmarked after the sweep phase must be finalized before they are freed. Unmarked objects without finalizers may be freed immediately unless referred to by an unmarked finalizable object. All objects referred to by a finalizable object must remain on the heap until after the object has been finalized.</span></div>
<div></div>
<div style="text-align: justify;"></div>
<div style="text-align: justify;"><b>Copying</b></div>
<div style="text-align: justify;"><span mce_style="font-weight: normal;" style="font-weight: normal; ">The copying collection technique can be dramatically faster than mark-sweep because it is able to dismiss garbage objects without ever scanning or analyzing them. Instead of simply removing garbage objects from their position in memory, it relocates all ?non-garbage? objects to an entirely new location in memory, trashing everything left-over in the memory. It does this by splitting its allocated memory into two sections: the active section and the unused section. In the active section, objects are stacked on top of each other contiguously, making object allocation extremely efficient. New objects are allocated simply by placing them on top of the existing heap. When it runs out of free memory, the garbage collector traces through all reachable objects and copies them contiguously to the unused section of memory.</span></div>
<div style="text-align: justify;"><span mce_style="font-weight: normal;" style="font-weight: normal; ">The active section of memory is still full of reachable and unreachable objects, but that doesn't matter since all the reachable objects have been copied to the unused section. Then, the active section and unused section switch places, dismissing the previous section of memory. When the new active section becomes full, the process is repeated again and the sections are swapped. This approach has the advantage of providing excellent allocation speed and it virtually eliminates fragmentation. The downside, however, is that long-living objects are continuously swapped between the two sections every time the collector is run. Additionally, it requires twice the amount of memory to run effectively.</span></div>
<div style="text-align: justify;"><span mce_style="font-weight: normal;" style="font-weight: normal; "><br /></span></div>
<div>
<p style="text-align: justify;"><b>Mark-Compact</b></p>
<p style="text-align: justify;"><b><span style="font-weight: normal; ">To account for the benefits of the copying collector while considering memory constraints and long-lived objects, the mark-compact collector was formed. Though it is a bit more complex than copying collectors, the fundamental idea is the same. There is a definite separation between the active section of the memory and the free/unused section. However, unlike the copying collector, the mark-compact collector scans for all reachable objects and compacts them at the bottom of the heap, leaving the remaining memory free for consumption. The catch is that it doesn?t have to fully compact the memory each time, and since long-lived objects tend to get pushed to the bottom of the heap, they are not as frequently collected and compacted.</span></b></p>
</div>
<div style="text-align: justify;"><b>Generational</b></div>
<div style="text-align: justify;"><span mce_style="font-weight: normal;" style="font-weight: normal; ">To further account for the differentiation between handling short-lived and long-lived objects, the generational approach was developed. In a generational collection, the heap is divided into multiple generations. Objects are created in the base (youngest) generation, and are promoted to higher (older) generations after passing some form of criteria, usually related to the age of the object. Garbage collection can be done at different time intervals and even using different techniques based on the generation the object is in. The only problem with this approach is when an older generation object references a younger generation object. Since the tracing collector does not trace into older generation references, this intergenerational reference gets lost in the mix if it is not referenced by some other object in its own generation. Luckily, there are only two ways for an older object to reference a younger object: either a reference in the older object is modified to refer to a younger object, or a young object that refers to other young objects gets promoted to an older generation. Languages that employ a generational collector account for this problem by maintaining a list of intergenerational references whenever such an occasion occurs.</span></div>
<div style="text-align: justify;"><span mce_style="font-weight: normal;" style="font-weight: normal; "><br /></span></div>
<div style="text-align: justify;"><span mce_style="font-weight: normal;" style="font-weight: normal; "><br /></span></div>
<div style="text-align: justify;"><b>Parallel Copying</b></div>
<div style="text-align: justify;"><span mce_style="font-weight: normal;" style="font-weight: normal; ">With the advent of multi-processor systems, many garbage collection techniques have needed multi-thread aware implementations. The parallel copying collection is a version of copying collection that runs as many threads as there are CPUs, preventing the workload from being restricted to only one CPU. The standard copying collection is unable to spread the workload to different processors, which creates an unnecessary bottleneck in performance. Compared with traditional copying collection, parallel copying has a potential speed increase by a factor equal to the number of CPUs available.</span></div>
<div style="text-align: justify;"></div>
<div style="text-align: justify;"></div>
<div style="text-align: justify;"><b>Concurrent</b></div>
<div style="text-align: justify;"><span mce_style="font-weight: normal;" style="font-weight: normal; ">The concurrent approach was developed to make the application execute as seamlessly as possible alongside (and at the same time as) the garbage collector. In order to accomplish this, it must first halt all other CPU activity to mark all reachable objects. Once it has completed that operation, it creates several garbage collection threads that execute concurrently with the program based on the marked and unmarked objects. Each thread does its part to remove garbage objects from memory.</span></div>
<div style="text-align: justify;">Parallel Scavenge</div>
<div style="text-align: justify;"><span mce_style="font-weight: normal;" style="font-weight: normal; ">The parallel scavenge collector is similar to the parallel copying collector; however, it is optimized for large memory heaps (10GB plus) on multiple-CPU systems. The approach is designed to reduce pauses and maximize throughput. It is rarely used on anything but servers.</span></div>
<div style="text-align: justify;"></div>
<div style="text-align: justify;"></div>
<div style="text-align: justify;"><b>Finalization</b></div>
<div style="text-align: justify;"><span mce_style="font-weight: normal;" style="font-weight: normal; ">Though not exactly a complete garbage collection technique, it is important to recognize how object finalization is accounted for in managed memory languages. Traditionally, languages without automated memory management (such as C++) provided destructors for their objects to free any resources that the object might consume. The terminology and syntax for finalization is similar, but the implementation is quite different. Since object ?destruction? is not always explicit in different garbage collection techniques (ex: copying collection), the compiler must take extra steps to explicitly call a finalization method when an object is freed from memory. Specifically, it must maintain a list of objects with finalizers, determine when those objects are removed from memory, prevent them from being removed from memory, execute their finalize method, and then place them back into memory to be marked as ?garbage? and collected once more. As you can no doubt see, finalization defeats many of the benefits of various garbage collection techniques and should only be used when absolutely necessary.</span></div>
<div style="text-align: justify;"><span mce_style="font-weight: normal;" style="font-weight: normal; "><br /></span></div>
<div style="text-align: justify;"><span mce_style="font-weight: normal;" style="font-weight: normal; "><br /></span></div>
<div style="text-align: justify;"><b>Java Implementation</b></div>
<div style="text-align: justify;"><span mce_style="font-weight: normal;" style="font-weight: normal; ">Java, specifically more recent versions of the JVM, implements a two-generation (young and old) approach with different collection techniques for each generation. The default collector for the young generation is the copying collector and the default collector for the old generation is the mark-compact collector. For multiple-CPU systems, Java provides the option of a parallel copying collector or a parallel scavenge collector for the young generation and a concurrent collector for the old generation. Since the vast majority of newly created objects die young,  Java's use of a copying collector on the young generation and a mark-compact on the older generation appears to provide a good mix of technologies for optimal speeds.</span></div></p>
<p style="text-align: justify;">Got these straight from::</p>
<p><span mce_style="font-weight: normal;" style="font-weight: normal; "><span mce_name="strong" mce_style="font-weight: bold;" style="font-weight: bold; "><span mce_style="font-weight: normal;" style="font-weight: normal; "><span mce_style="font-family: arial, sans-serif; line-height: normal;" style="font-family: arial, sans-serif; line-height: normal; "></span></span></span></span></p>
<p><span mce_name="strong" mce_style="font-weight: bold;" style="font-weight: bold; "></span></p>
<p><span mce_name="strong" mce_style="font-weight: bold;" style="font-weight: bold; "></span></p>
<div style="text-align: justify;"><span mce_name="strong" mce_style="font-weight: bold;" style="font-weight: bold; "><a href="http://www.ibm.com/developerworks/java/library/j-jtp10283/" mce_href="http://www.ibm.com/developerworks/java/library/j-jtp10283/">http://www.ibm.com/developerworks/java/library/j-jtp10283/</a><br /></span></div>
<div style="text-align: justify;"><span mce_name="strong" mce_style="font-weight: bold;" style="font-weight: bold; "><a href="http://www.osnews.com/story/6864" mce_href="http://www.osnews.com/story/6864">http://www.osnews.com/story/6864</a><br /></span></div>
<div style="text-align: justify;"><span mce_name="strong" mce_style="font-weight: bold;" style="font-weight: bold; "><a href="http://www.javaworld.com/javaworld/jw-08-1996/jw-08-gc.html?page=8" mce_href="http://www.javaworld.com/javaworld/jw-08-1996/jw-08-gc.html?page=8">http://www.javaworld.com/javaworld/jw-08-1996/jw-08-gc.html?page=8</a></span></div></p>
</div>
<p></span></p>
